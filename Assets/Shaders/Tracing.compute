#pragma kernel CSMain

#include "Tracing/global.hlsl"
#include "Tracing/structures.hlsl"
#include "Tracing/random.hlsl"
#include "Tracing/functions.hlsl"
#include "Tracing/intersection.hlsl"

// trace a ray and returns hit immediately (for shadow rays)
bool TraceHit(Ray ray, float targetDist)
{
    HitInfo bestHit = CreateHitInfo();
    // check tlas intersection
    //return IntersectTlasTreeFast(ray, bestHit, targetDist);
    return IntersectTlasFast(ray, bestHit, targetDist);
}

// trace a ray and detect nearest hit
HitInfo Trace(Ray ray)
{
    HitInfo bestHit = CreateHitInfo();
    // check tlas intersection
    //IntersectTlasTree(ray, bestHit);
    IntersectTlas(ray, bestHit);
    return bestHit;
}

// return shading info based on ray and hitinfo
float3 Shade(inout Ray ray, HitInfo hit)
{
    if (hit.dist < 1.#INF)
    {
        //ray.energy = 0.0;
        //return hit.norm * 0.5 + 0.5;
        
        // sample directional light
        Ray shadowRay = CreateRay(hit.pos + hit.norm * 1e-5, _DirectionalLight.xyz);
        float3 lightContrib = _DirectionalLight.w;
        if (_DirectionalLight.w <= 0.0 || TraceHit(shadowRay, 1.#INF))
        {
            lightContrib = 0.0;
        }
        else
        {
            lightContrib *= hit.colors.albedo * saturate(dot(hit.norm, _DirectionalLight.xyz)) * _DirectionalLightColor;
        }
        
        float random = rand();
        if(hit.mode >= 3.0)
        {
            // transparent workflow
            float ior = hit.colors.smoothness * 2.0 + 1.0;
            float kr = saturate(Fresnel(ray.dir, hit.norm, ior));
            float outside = dot(ray.dir, hit.norm);
            ray.origin = hit.pos + sign(outside) * hit.norm * 1e-5;
            if (random < kr)
            {
                ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), 1e5 * kr));
                ray.energy *= clamp(1.0 / kr, 0.0, 1e2) * hit.colors.specular * clamp(dot(hit.norm, ray.dir), 0.8, 1.0);
                lightContrib *= saturate(kr);
            }
            else
            {
                kr = 1.0 - kr;
                ray.dir = normalize(SampleHemisphere3(refract(ray.dir, hit.norm, 1.0 / ior), 1e5 * kr));
                ray.energy *= clamp(1.0 / kr, 0.0, 1e2) * hit.colors.albedo * clamp(dot(-hit.norm, ray.dir), 0.8, 1.0);
                lightContrib *= saturate(kr);
            }
        }
        else
        {
            // opaque workflow
            ray.origin = hit.pos + hit.norm * 1e-5;
            float specChance = dot(hit.colors.specular, 0.333333333333);
            float diffChance = dot(hit.colors.albedo, 0.33333333333);
            float sum = 1.0 / (specChance + diffChance);
            specChance *= sum;
            diffChance *= sum;
            if (random < specChance)
            {
                float alpha = 1e5 * hit.colors.smoothness * hit.colors.smoothness;
                ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), alpha));
                ray.energy *= 1.0 / specChance * hit.colors.specular * clamp(dot(hit.norm, ray.dir), 0.5, 1.0);
            }
            else
            {
                ray.dir = normalize(SampleHemisphere3(hit.norm, 0.0));
                ray.energy *= 1.0 / diffChance * 2.0 * hit.colors.albedo * saturate(dot(hit.norm, ray.dir));
            }
        }
        return hit.colors.emission + lightContrib;
        
    }
    else
    {
        // hit skybox
        ray.energy = 0.0;
        float raySampleScale = max(max(abs(ray.dir.x), abs(ray.dir.y)), abs(ray.dir.z));
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.dir / raySampleScale, 0).xyz * _SkyboxIntensity;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // get output dimensions
    uint width, height;
    _FrameTarget.GetDimensions(width, height);
    // create camera
    Camera camera = CreateCamera();
    // save pixel center
    float2 center = float2(id.xy);
    // init random seed
    rng_initialize(center, _FrameCount);
    // generate ray from camera
    Ray ray = CreateCameraRay(camera, 2.0 * (center + camera.offset) / float2(width, height) - 1.0);
    // trace ray
    float3 color = 0.0;
    for (int i = 0; i < _TraceDepth; i++)
    {
        // get nearest ray hit
        HitInfo hit = Trace(ray);
        // accumulate energy (color)
        color += ray.energy * Shade(ray, hit);
        // if ray has no energy, stop tracing
        if (!any(ray.energy))
            break;
    }
    // write to frame target
    _FrameTarget[id.xy] = float4(color, 1.0);
}
