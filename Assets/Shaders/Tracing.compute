#pragma kernel CSMain

#include "Tracing/global.hlsl"
#include "Tracing/structures.hlsl"
#include "Tracing/random.hlsl"
#include "Tracing/functions.hlsl"
#include "Tracing/intersection.hlsl"

// trace a ray and returns hit immediately (for shadow rays)
bool TraceHit(Ray ray, float targetDist)
{
    HitInfo bestHit = CreateHitInfo();
    // check tlas intersection
    uint size, stride;
    _TNodes.GetDimensions(size, stride);
    for (uint i = 0; i < size; i++)
    {
        TLASNode node = _TNodes[i];
        Ray localRay = PrepareTreeEnterRay(ray, node.transformIdx);
        if (IntersectBox2(localRay, node.boundMax, node.boundMin))
        {
            // intersect with BLAS tree
            PrepareTreeEnterHit(localRay, bestHit, node.transformIdx);
            if (IntersectBVHTreeFast(localRay, node.rootIdx, targetDist))
                return true;
            PrepareTreeExit(ray, bestHit, node.transformIdx);
        }
    }
    return false;
}

// trace a ray and detect nearest hit
HitInfo Trace(Ray ray)
{
    HitInfo bestHit = CreateHitInfo();
    // check tlas intersection
    uint size, stride;
    _TNodes.GetDimensions(size, stride);
    for (uint i = 0; i < size; i++)
    {
        TLASNode node = _TNodes[i];
        Ray localRay = PrepareTreeEnterRay(ray, node.transformIdx);
        if (IntersectBox2(localRay, node.boundMax, node.boundMin))
        {
            // intersect with BLAS tree
            PrepareTreeEnterHit(localRay, bestHit, node.transformIdx);
            IntersectBVHTree(localRay, bestHit, node.rootIdx, node.transformIdx);
            PrepareTreeExit(ray, bestHit, node.transformIdx);
        }
    }
    return bestHit;
}

// return shading info based on ray and hitinfo
float3 Shade(inout Ray ray, HitInfo hit)
{
    if (hit.dist < 1.#INF)
    {
        float random = rand();
        if(hit.mode > 0.0)
        {
            // transparent workflow
            float ior = hit.smoothness * 2.0 + 1.0;
            float kr = saturate(Fresnel(ray.dir, hit.norm, ior));
            float outside = dot(ray.dir, hit.norm);
            ray.origin = hit.pos + sign(outside) * hit.norm * 1e-5;
            if (random < kr)
            {
                ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), 100000.0 * kr));
                ray.energy *= clamp(1.0 / kr, 0.0, 1e2) * hit.colors.specular * clamp(dot(hit.norm, ray.dir), 0.8, 1.0);
            }
            else
            {
                kr = 1.0 - kr;
                ray.dir = normalize(SampleHemisphere3(refract(ray.dir, hit.norm, 1.0 / ior), 100000.0 * kr));
                ray.energy *= clamp(1.0 / kr, 0.0, 1e2) * hit.colors.albedo * clamp(dot(-hit.norm, ray.dir), 0.8, 1.0);
            }
        }
        else
        {
            // opaque workflow
            ray.origin = hit.pos + hit.norm * 1e-5;
            float specChance = dot(hit.colors.specular, 0.333333333333);
            float diffChance = dot(hit.colors.albedo, 0.33333333333);
            float sum = 1.0 / (specChance + diffChance);
            specChance *= sum;
            diffChance *= sum;
            if (random < specChance)
            {
                float alpha = 10000.0 * hit.smoothness * hit.smoothness;
                ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), alpha));
                ray.energy *= 1.0 / specChance * hit.colors.specular * saturate(dot(hit.norm, ray.dir));
            }
            else
            {
                ray.dir = normalize(SampleHemisphere3(hit.norm, 0.0));
                ray.energy *= 1.0 / diffChance * 2.0 * hit.colors.albedo * saturate(dot(hit.norm, ray.dir));
            }
        }
        return hit.colors.emission;
        
    }
    else
    {
        // hit skybox
        ray.energy = 0.0;
        float raySampleScale = max(max(abs(ray.dir.x), abs(ray.dir.y)), abs(ray.dir.z));
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.dir / raySampleScale, 0).xyz * _SkyboxIntensity;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // get output dimensions
    uint width, height;
    _FrameTarget.GetDimensions(width, height);
    // create camera
    Camera camera = CreateCamera();
    // save pixel center
    float2 center = float2(id.xy);
    // init random seed
    rng_initialize(center, _FrameCount);
    // generate ray from camera
    Ray ray = CreateCameraRay(camera, 2.0 * (center + camera.offset) / float2(width, height) - 1.0);
    // trace ray
    float3 color = 0.0;
    for (int i = 0; i < _TraceDepth; i++)
    {
        // get nearest ray hit
        HitInfo hit = Trace(ray);
        // accumulate energy (color)
        color += ray.energy * Shade(ray, hit);
        // if ray has no energy, stop tracing
        if (!any(ray.energy))
            break;
    }
    // write to frame target
    _FrameTarget[id.xy] = float4(color, 1.0);
}
