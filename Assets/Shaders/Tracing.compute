#pragma kernel CSMain

#include "Tracing/global.hlsl"
#include "Tracing/structures.hlsl"
#include "Tracing/random.hlsl"
#include "Tracing/functions.hlsl"
#include "Tracing/intersection.hlsl"

// trace a ray and returns hit immediately (for shadow rays)
bool TraceHit(Ray ray, float targetDist)
{
    //uint count, stride, i;
    //if (IntersectBVHTreeFast(ray, 0, targetDist))
    //    return true;
    return false;
}

// trace a ray and detect nearest hit
HitInfo Trace(Ray ray)
{
    HitInfo bestHit = CreateHitInfo();
    // check tlas intersection
    uint size, stride;
    _TNodes.GetDimensions(size, stride);
    for (uint i = 0; i < size; i++)
    {
        TLASNode node = _TNodes[i];
        Ray localRay = PrepareTreeEnterRay(ray, node.transformIdx);
        if (IntersectBox2(localRay, node.boundMax, node.boundMin))
        {
            // intersect with BLAS tree
            PrepareTreeEnterHit(localRay, bestHit, node.transformIdx);
            InersectBVHTree(localRay, bestHit, node.rootIdx, node.transformIdx);
            PrepareTreeExit(ray, bestHit, node.transformIdx);
        }
    }
    return bestHit;
}

// return shading info based on ray and hitinfo
float3 Shade(inout Ray ray, HitInfo hit)
{
    if (hit.dist < 1.#INF)
    {
        //return hit.norm * 0.5 + 0.5; // debug normal

        // check whether if is light
        if (dot(hit.colors.emission, 0.3) > 0.9)
        {
            ray.energy = 0.0;
            return hit.colors.emission;
        }
        else if(hit.mode > 0.0)
        {
            // transparent workflow
            float random = rand();
            float ior = hit.smoothness * 2.0 + 1.0;
            float kr = Fresnel(ray.dir, hit.norm, ior);
            float outside = dot(ray.dir, hit.norm);
            ray.origin = hit.pos + sign(outside) * hit.norm * 1e-5;
            if (random < kr)
            {
                ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), 10000.0));
                //ray.dir = normalize(reflect(ray.dir, hit.norm));
                float coeff = clamp(1.0 / kr, 1e-2, 1.0);
                //float coeff = 1.0 / kr;
                ray.energy *= coeff * 5.0 * hit.colors.specular * saturate(dot(hit.norm, ray.dir));
            }
            else
            {
                ray.dir = normalize(SampleHemisphere3(refract(ray.dir, hit.norm, 1.0 / ior), 10000.0));;
                //ray.dir = normalize(refract(ray.dir, hit.norm, 1.0 / ior));
                float coeff = clamp(1.0 / (1.0 - kr), 1e-2, 1.0);
                //float coeff = 1.0 / (1.0 - kr);
                ray.energy *= coeff * 2.0 * hit.colors.albedo * saturate(dot(-hit.norm, ray.dir));
            }
            //ray.dir = normalize(refract(ray.dir, hit.norm, 1.0 / ior));
            //ray.energy *= 2.0 * hit.colors.albedo;
            return hit.colors.emission;
        }
        else
        {
            // opaque workflow
            ray.origin = hit.pos + hit.norm * 1e-5;
            float specChance = dot(hit.colors.specular, 0.333333333333);
            float diffChance = dot(hit.colors.albedo, 0.33333333333);
            float sum = specChance + diffChance;
            specChance /= sum;
            diffChance /= sum;
            float random = rand();
            if (random < specChance)
            {
                float alpha = pow(10000.0, hit.smoothness);
                ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), alpha));
                ray.energy *= 1.0 / specChance * hit.colors.specular *
                    saturate(dot(hit.norm, ray.dir) * (alpha + 2.0) / (alpha + 1.0));
                //ray.dir = reflect(ray.dir, hit.norm);
                //ray.energy *= 1.0 / specChance * hit.colors.specular * saturate(dot(hit.norm, ray.dir));
            }
            else
            {
                ray.dir = normalize(SampleHemisphere3(hit.norm, 1.0));
                ray.energy *= 1.0 / diffChance * 2.0 * hit.colors.albedo * saturate(dot(hit.norm, ray.dir));
            }
            return hit.colors.emission;
        }
        // shadow ray
        //Ray shadowRay = CreateRay(hit.pos, _DirectionalLight.xyz);
        //if (TraceHit(shadowRay, 1.#INF))
        //{
        //    return hit.emission;
        //}
        //return hit.colors.emission + saturate(dot(hit.norm, _DirectionalLight.xyz)) * _DirectionalLight.w * hit.colors.albedo;
        
    }
    else
    {
        // hit skybox
        ray.energy = 0.0;
        float raySampleScale = max(max(abs(ray.dir.x), abs(ray.dir.y)), abs(ray.dir.z));
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.dir / raySampleScale, 0).xyz;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // save pixel center
    PixelCenter = float2(id.xy);
    // get output dimensions
    uint width, height;
    _FrameTarget.GetDimensions(width, height);
    // create camera
    Camera camera = CreateCamera();
    // generate ray from camera
    Ray ray = CreateCameraRay(camera, float2(id.xy), float2(width, height));
    // trace ray
    float3 color = 0.0;
    for (int i = 0; i < _TraceDepth; i++)
    {
        // get best ray hit
        HitInfo hit = Trace(ray);
        // accumulate energy (color)
        color += ray.energy * Shade(ray, hit);
        // if ray has no energy, stop tracing
        if(!any(ray.energy))
            break;
    }
    // write to frame target
    _FrameTarget[id.xy] = float4(color, 1.0);
}
