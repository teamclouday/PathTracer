#pragma kernel CSMain

#include "Tracing/global.hlsl"
#include "Tracing/structures.hlsl"
#include "Tracing/random.hlsl"
#include "Tracing/functions.hlsl"
#include "Tracing/intersection.hlsl"

// trace a ray and returns hit immediately (for shadow rays)
bool TraceHit(Ray ray, float targetDist)
{
    uint count, stride, i;
    //_Meshes.GetDimensions(count, stride);
    //for (i = 0; i < count; i++)
    //{
    //    if (IntersectMeshObjectFast(ray, _Meshes[i], targetDist))
    //        return true;
    //}
    if (IntersectBVHTreeFast(ray, 0, targetDist))
        return true;
    return false;
}

// trace a ray and detect nearest hit
HitInfo Trace(Ray ray)
{
    HitInfo bestHit = CreateHitInfo();
    // intersect with mesh objects
    //uint count, stride, i;
    //_Meshes.GetDimensions(count, stride);
    //for (i = 0; i < count; i++)
    //{
    //    IntersectMeshObject(ray, bestHit, _Meshes[i]);
    //}
    // intersect with BVH tree
    InersectBVHTree(ray, bestHit, 0);
    return bestHit;
}

// return shading info based on ray and hitinfo
float3 Shade(inout Ray ray, HitInfo hit)
{
    if (hit.dist < 1.#INF)
    {
        //return hit.norm * 0.5 + 0.5; // debug normal
        // prepare next ray
        ray.origin = hit.pos + hit.norm * 1e-8;
        //ray.dir = SampleHemisphere3(hit.norm, pow(1000.0, 0.8 * 0.8));
        //ray.energy *= 2.0 * hit.colors.albedo * dot(ray.dir, hit.norm);
        //hit.colors.albedo = min(hit.colors.albedo, 1.0 - hit.colors.specular);
        float specChance = dot(hit.colors.specular, 0.333333333333);
        float diffChance = dot(hit.colors.albedo, 0.33333333333);
        float sum = specChance + diffChance;
        specChance /= sum;
        diffChance /= sum;
        float random = rand();
        if (random < specChance)
        {
            float alpha = pow(1000.0, hit.smoothness * hit.smoothness);
            ray.dir = normalize(SampleHemisphere3(reflect(ray.dir, hit.norm), alpha));
            ray.energy *= 1.0 / specChance * hit.colors.specular *
                saturate(dot(hit.norm, ray.dir) * (alpha + 2.0) / (alpha + 1.0));
            //ray.dir = reflect(ray.dir, hit.norm);
            //ray.energy *= 1.0 / specChance * hit.colors.specular * saturate(dot(hit.norm, ray.dir));
        }
        else
        {
            ray.dir = normalize(SampleHemisphere3(hit.norm, 1.0));
            ray.energy *= 1.0 / diffChance * 2.0 * hit.colors.albedo * saturate(dot(hit.norm, ray.dir));
        }
        Ray shadowRay = CreateRay(hit.pos, _DirectionalLight.xyz);
        if (TraceHit(shadowRay, 1.#INF))
        {
            return hit.colors.emission;
        }
        return hit.colors.emission + saturate(dot(hit.norm, _DirectionalLight.xyz)) * _DirectionalLight.w * hit.colors.albedo;
    }
    else
    {
        // hit skybox
        ray.energy = 0.0;
        float raySampleScale = max(max(abs(ray.dir.x), abs(ray.dir.y)), abs(ray.dir.z));
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, ray.dir / raySampleScale, 0).xyz;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // save pixel center
    PixelCenter = float2(id.xy);
    // get output dimensions
    uint width, height;
    _FrameTarget.GetDimensions(width, height);
    // get new pixel pos
    float2 uv = (id.xy + _PixelOffset) / float2(width, height) * 2.0 - 1.0;
    // generate ray from camera
    Ray ray = CreateCameraRay(uv);
    // trace ray
    float3 color = 0.0;
    for (int i = 0; i < _TraceDepth; i++)
    {
        // get best ray hit
        HitInfo hit = Trace(ray);
        // accumulate energy (color)
        color += ray.energy * Shade(ray, hit);
        // if ray has no energy, stop tracing
        if(!any(ray.energy))
            break;
    }
    // write to frame target
    _FrameTarget[id.xy] = float4(color, 1.0);
}
